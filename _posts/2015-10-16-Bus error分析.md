---
layout: default
title: Bus error分析
comments: true
kind: knowledge
---

本文章参考自:[csdn1](http://www.cnblogs.com/li-hao/archive/2012/01/31/2333952.html) 
[csdn2](http://bbs.csdn.net/topics/390429233?page=1)

  1. 在开启了内存对齐检查功能时，若访问未对齐的数据时，会bus error。
  2. 其它原因，一些访问违例的行为。

###总线错误
引起原因： 几乎总是由于对未对齐的读或写引起的。它之所以称为总线错误是因为对未对齐的内存访问时，被阻塞的组件就是地址总线。

对齐（alignment）数据项只能存储在地址是数据项大小的整数倍的内存位置上，这样可以加速内存访问。如：访问一个8字节的double的数据时，地址只能是8的整数倍，所以存储一个double的地址只能是24，8008，但不能存储于地址1006因为它不能被8整除，只要保证这个原则，就可以保证一个原子项数据不会跨页或cache块的边界。

引起总线错误的小程序：
union 
{
    char a[10];
    int i;
}u;

int *p =(int*)&(u.a[1]);

*p =17;/*p中未对齐的地址将会引起总线错误*/
因为数组和int的联合确保了a是按照int的4字节来对齐的，所以“a+1”肯定不是int来对齐的。（后面专门讨论下内存对齐问题）

###总结
在设计存储格式时，尽量选择对齐的方式，既能提高存储速度，也能避免bus error。
