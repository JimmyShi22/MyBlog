##多源最短路径
###Floyd算法
时间复杂度：O(V^3)

基本思想：三重循环遍历所有的顶点，若i，j两个点间，有一个点k，经过路径i->k->j要小于i->j则更新i->j的距离。三重循环结束，即可得到两两点间的距离最值。
需要注意的是，i，j，k必须各不相同。

参考：[http://hihocoder.com/problemset/problem/1089](http://hihocoder.com/problemset/problem/1089)

伪代码：

```
for k = 1 .. N
    for i = 1 .. N 
        for j = 1 .. N
            若i, j, k各不相同
                MinDistance[i, j] = min{MinDistance[i, j], MinDistance[i, k] + MinDistance[k, j]}
```

##单源最短路径--SSSP
###Dijkstra
时间复杂度：O(V*V+E) -> O（E*logV）

简单理解：以顶点为单位，开始时，源点d[0] = 0，其他d[x] = +∞。设置一个set，存放已经计算好的顶点。开始时候，只有源点在set中。
每次选取一个与set邻接的顶点vx，并且vx距离v0最近，加入到set中，并更新vx邻接的顶点vy的d为d[vy] = min(d[vy], d[vx] + dis(x, y))。
邻接的顶点vx的选取可以用heap来优化，使得复杂度下降到O（E*logV）

不足：边的权值不能为负数

###Bellman-Ford
时间复杂度：O(VE)

简单理解：核心，relax算法，每次



###SPFA (Shortest Path Faster Algorithm)
参考：[http://hihocoder.com/problemset/problem/1093](http://hihocoder.com/problemset/problem/1093)

###A*算法
